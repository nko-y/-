#### 图形渲染管线

（1）应用程序阶段（CPU端）

- 粗粒度剔除。以包围盒为单位视锥剔除
- 加载HDD(硬盘) $\rightarrow$ RAW(系统内存) $\rightarrow$ VRAM(显存)
- 设置每个对象的渲染状态(shader、纹理、材质)
- 发送Draw Call(渲染状态+图元信息)

（2）几何处理阶段

- 顶点着色器(坐标变换(模型空间-齐次裁剪空间-透视除法-归一化NDC)、逐顶点光照)
- 曲面细分着色器
- 几何着色器
- 裁剪，裁剪掉不在相机视野内的东西
- 背面剔除
- 屏幕映射

（3）光栅化

- 三角形设置
- 三角形遍历，找到哪些像素被三角形覆盖

（4）像素处理阶段

- 片段着色器
- 逐片元操作：
  - alpha-test
  - 模板测试
  - 深度测试
  - alpha blend



#### URP

（1）流程：渲染阴影所需的shadowmap，从前到远渲染不透明的物体，渲染天空盒，从远到近渲染透明物体，后处理

- 每一个过程都可能提交多个DrawCall这个过程称呼为Render pass，他的作用就是将输入的信息渲染到一个render target上（中间内存缓冲区/渲染目标纹理RTT）



#### 剔除

（1）距离剔除(应用程序阶段)

（2）视锥剔除(应用程序阶段)：用包围盒判断物体是否位于视锥棱台内

（3）遮挡剔除(应用程序阶段)：构建一个低分辨率的zbuffer

（4）视口剔除(投影变换之后屏幕映射之前)

（5）背面剔除(几何处理阶段)



#### 实例化

（1）目的：将数据一次性发送给GPU然后使用一个绘制函数让OpenGL利用这些数据绘制多个物体

（2）以OpenGL为例

- 方法一：在使用实例化渲染调用时需要给定一个额外的参数，实例数量。在使用实例化渲染调用时gl_InstanceID会从0开始在每个实例被渲染时递增1【但如果要渲染非常多的实例的时候我们最终会超过最大能发送至着色器的uniform数据大小上限】

- 方法二：实例化数组，仅在顶点着色器渲染一个新的实例的时候才会更新。使用VBO传入offset偏移后使用glVertexAttribDivisor(2, 1)
  - 第一个参数是需要的顶点属性
  - 第二个参数是属性除数默认情况下除数是0顶点着色器每次迭代时更新，1表示渲染一个新实例的时候更新



















