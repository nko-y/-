#### 内存分页与虚拟内存机制

（1）分页：将内存划分为一个个页（page），每个页都是相同大小的划分单位(通常大小为4KB)

- C++：堆、栈、代码段、全局区

（2）虚拟内存：

- 每个进程有自己独立的虚拟内存空间，通过页表映射为物理内存空间
- 通过页表可以查询映射关系，由于地址空间较大因而页表通常有多级
- 访问页表本身也是一种访存，因而增加了一级页表的cache称为TLB(快表)
- 每个进程都有自己独立的虚拟内存，高地址的内核空间 + 低地址的用户空间

（3）Swap机制：

- 虚拟内存远大于物理内存，因而会将外存(磁盘)作为额外的物理存储介质，通过一定换入换出机制使得用户感觉可以使用一个超大的内存空间
- 由于存在外存换入换出的IO，因而会引入额外的延迟(时间换空间)

（4）zRAM技术

- 是一种辅助Swap机制的软件方法，首先对物理内存专门划分出一块区域zRAM，当物理内存不足时将需要换到外存的物理内存压缩后放到物理内存上，当需要用到该物理内存时再解压出来。

（5）移动端虚拟内存

- 问题：移动端读写寿命短，所以不会用Swap机制
- 物理内存轻微不足时：删除干净页，zRAM技术
- 物理内存继续不足时：各进程通知memory warning，收到通知的进程调用自定义函数主动释放内存
- 物理内存严重不足时：按照优先级干掉进程直到物理内存足够



#### 虚拟内存分配

（1）read：文件内容先缓存进内核空间的 page cache 里，然后再将 page cache 的内容拷贝到用户空间的 buffer 中

（2）write：在将修改后的用户空间 buffer 内容复制到内核空间的 page cache 上，然后内核空间再把 page cache 的内容立即回写到文件上

（3）mmap：将虚拟空间映射到外存文件(文件内容缓存进page cache，虚拟内存映射到page cache)

- 修改虚拟内存后，page cache不会立即写回，可以多次修改一起写回
- 在处理大文件/频繁访问文件的情况，我们应当利用 mmap 来读写文件而非传统的 read/write

- 匿名映射(将用户空间的一段虚拟内存直接映射到某段物理内存)，匿名页(该段虚拟内存)

（4）malloc/free：分配虚拟内存，虚拟内存第一次被访问后才会真正分配物理内存空间(OS的写时分配行为)

- 分配内存块前塞入header数据(包含尺寸等信息)
- malloc分配内存首地址自动对齐
- malloc不一定会调用系统调用
  - 首先尝试在自己的内存池中寻找有无空闲空间
  - 如果用户分配的内存小于128KB，通过系统调用brk将内存块上移一小块位置并返回器内存块地址，归还时缓存在内存池中
  - 如果用户分配的内存大于128KB，通过系统调用mmap()申请内存(虚拟内存映射物理内存)，并在munmap时把内存归还给操作系统

（5）new/delete：

- 在使用 new[]来分配内存时需要额外插入多一个header用来存放objects数量
  - 这里int struct都可以通过sizeof得到大小从而获取到数量
  - 但是class因为存在子类赋值给基类的现象所以不一定能知道该类的具体大小

![newdelete](./img/newdelete.jpg)

（6）内存问题：

- 内存碎片：因为被过多的碎片切割了自由内存，即使自由内存表面上有足够的空间分配，但分配请求仍然可能会失败。
- 内存扩散：多次连续分配的内存在物理空间中不容易连续，从而导致 cache 命中率越来越低

（7）多线程环境：malloc/free本身线程安全，但是其内部需要加全局锁造成性能下降



#### 内存分配策略

（1）栈式分配器：不断地再分配内存块出去，但释放内存行为却不做任何操作

（2）基于栈区/静态存储区的内存资源：不需要malloc

（3）单帧内存分配器：分配的内存仅在当前帧有效，结束时自动释放掉所有内存

（4）双缓冲内存分配器：分配的内存在当前帧和下一帧有效

（5）可回收内存分配器：

- 空闲链表法：将释放的内存添加到空闲链表中
- 自动整理碎片
- 自动垃圾回收：单次标记批量回收

（6）对象池



参考文献：

1. [游戏架构设计：内存管理](https://www.cnblogs.com/KillerAery/p/10765893.html)