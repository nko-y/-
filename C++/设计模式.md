#### 工厂模式

（1）简单工厂模式：有一个工厂类根据传入的参数(例如字符串)选择返回哪种产品的类对象

（2）工厂方法模式：定义一个工厂方法接口，各自产品各自实现这些方法

（3）抽象工厂模式：各自产品实现各自的工厂方法接口(比如生产食物的工厂、生产饮料的工厂)，再定义一个接口提供这些服务的组合(createfood createdrink)，然后具体的工厂实现对应的方法(中餐厂生产茶和中餐)



#### 装饰器模式

继承机制继承现有功能并扩展新功能，关联(组合)机制将一个类装入另一个类套一个壳子

第二种扩展类的方法就叫做装饰器模式，更加灵活



#### 适配器模式

将一个类的接口变换成另一个接口，使得原本因接口不匹配而无法在一起工作的两个类能够在一起工作，同样也分为关联 / 继承

适配器提供转换桥梁，装饰器则是对原有接口扩展



#### 观察者模式(发布-订阅模式)

多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新

- 优点：降低了目标和观察者之间的耦合关系，两者之间是抽象耦合关系。目标和观察者之间建立了一套触发机制
- 缺点：目标和观察者之间的依赖关系并没有完全解除，可能出现循环引用的现象。当观察者对象很多时发布通知会花费很多时间，影响程序效率



#### 依赖倒置

通常情况我们会先设计最底层的基础，再设计高层功能，高层功能依赖于底层基础(底层调整就要改高层)

依赖倒置说的是在两者中间再加一层【抽象层】，高层依赖这一层抽象层，底层实现这层抽象层

高层次类依赖低层次类 $\rightarrow$ 低层次类依赖于抽象类



#### 开闭原则

对于扩展类应该是开放的

对于修改类应该是封闭的(对于稳定的代码尽量不要改动而是创建一个子类重写父类部分逻辑)



#### 继承和组合

（1）继承

- 优点
  - 创建子类的对象时，无需创建父类的对象
  - 子类能自动继承父类的接口
- 缺点
  - 父类和子类是高度耦合的，父类内部细节对子类可见如果父类的方法做了修改子类的方法必须做对应的修改
  - 子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为

（2）组合

- 优点

  - 两者是低耦合的状态，包含的对象的内部细节对于当前对象不可见
  - 可以在运行的时候动态的绑定所包含的对象，通过set方法给所包含对象赋值

- 缺点

  - 创建整体类对象时需要创建所有局部类的对象
  - 整体类不能自动获得和局部类相同的接口

  
