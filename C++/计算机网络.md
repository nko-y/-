#### 分层

（1）TCP/IP模型：应用层、传输层(TCP, UDP)、网络层(IP协议数据包转发路由)、链路层(数据传输与封装)

（2）OSI模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层



#### TCP和UDP

（1）区别：

- TCP面向连接，UDP面向无连接：TCP三次握手四次挥手，UDP支持一对一、一对多、多对一数据收发
- TCP可靠，UDP不可靠：无差别、不丢失、按序到达
- TCP基于字节流(拆分)，UDP基于报文(发送什么接收什么)

（2）收发数据：

- tcp：send, recv
  - IP层也会分片为什么还要TCP层的分段？因为想要小部分数据丢失的时候能够快速重传，而不需要进行整体重传
- udp：sendto, recvfrom
  - UDP不会进行分段，在IP层会根据MTU的限制进行分片
  - UDP一个要么没有到达，要么就全部收到进行重组

用户态数据系统调用到内核态变成socket，根据TCP(超过MSS就进行分段)还是UDP，加上报文头(IP分片)，经过网卡发送到互联网

MTU = IP头部 + TCP头部 + 数据块

MSS = 数据块

问题？客户端通过TCP和UDP分别发送了三个包，服务端会收到几个包？

- TCP可能受到一个(包很小)，两个，三个，... n个（会分段）
- 极限情况0个，一个，两个，三个(都没有丢失)



#### TCP如何实现可靠性传输

（1）重传机制：在一定时间没有收到接收端应答时会重传数据

- 停等协议
- 回退重传
- 选择性重传

（2）数据包检验机制：发送数据包时同时需要发送一个校验和，接收端收到数据包校验校验和，如果校验失败会要求发送端重传

（3）控制流机制：通过限制发送速率来确保数据包的可靠传输



#### 水平触发和边缘触发

（1）对象是IO多路复用

- select poll只有水平触发
- epoll默认水平触发也可以设置边缘触发

（2）目的：检测IO是否就绪，数据是否准备好？不知道客户端是否发送数据、建立数据【只是是否的关系，具体还是得IO函数来完成的】

（3）就绪通过什么形式告知：

- 可读事件：读缓冲区中有数据就会触发读事件(也可以设置一个水位，默认是1，只有大于水位才触发)。或者是全连接队列中有数据(有连接没有处理)。对端写端关闭，会触发当前端的读事件
- 可写事件：内核网络写缓冲区只要有可写空间就会触发写事件。连接建立成功

（4）怎么获取就绪数据：epoll_wait使得用户可以获得就绪事件

（5）区别

- 水平触发：只要满足IO就绪条件就会触发
  - epoll_wait没有处理下一次epoll_wait依旧可以获得就绪事件
  - epoll_wait没有完全处理全部数据
- 边缘触发：新的IO就绪事件到达就会触发一次【效率高些，因为少一些epoll_wait就少些用户内核态切换】
  - 上述水平触发两种情况拿不到通知

（6）总结：

- 可读事件采用水平触发，可写事件采取边缘触发(但linux并不支持)否则还得注销可写事件



#### UDP可靠性传输(QUIC协议)

借鉴TCP上述优点，模拟TCP可靠性传输方式比如确认机制、重传机制、校验机制等

（1）TCP协议问题：

- 升级TCP工作很困难
- TCP建立连接的延迟
- TCP存在队头阻塞问题
- 网络迁移需要重新建立TCP连接

（2）实现可靠传输：设计协议头部字段

核心：通过单向递增的Packet Number，配合StreamID与Offset字段可以支持乱序确认而不影响数据包的正确组装

- UDP Header
- Packet Header：
  - 首次建立连接用LongPacketHeader，主要包含SourceConnectionID和DestinationConnectionID，后续传输时只要固定住dest就不需要传输sourceid了，可以实现连接迁移功能
  - 日常传输数据用ShortPacketHeader，主要包含DestinationConnectionID、PacketNumber和负载数据
    - PacketNumber是每个报文独一无二的编号严格递增，就算PacketN丢失重传的值也会变大，以此解决TCP重传时序列号一致导致无法正确判断RTT的问题
    - 不需要再像TCP那样有序确认可以支持乱序确认，防止因为丢包重传阻塞在原地

- QUIC Frame Header
  - 一个Packet报文可以存放多个QUIC Frame，每个Frame都有明确的类型，针对类型不同功能也不同
    - Stream类型：一条HTTP请求：StreamID(多个并发传输的HTTP消息StreamID不同) + Offset(类似于TCP协议中的Seq序号保证数据的顺序性和可靠性) + Length(指明了Frame数据的长度) + 负载数据
  - 通过StreamID + Offset字段信息实现数据的有序性，比较两个数据包的StreamID和StreamOffset如果都是一样的就说明这两个数据包内容一致 <span style="color:red">这主要是Packet Number严格递增，重传数据包的Packet N+M与丢失数据包的Packet N编号并不一致的问题</span>

（3）解决TCP队头阻塞

- 问题描述：
  - 发送窗口的队头阻塞：把发送窗口大小的数据发送后没有任何应答ACK此时就会等待到超时重新发送窗口才会移动
  - 接收窗口队头阻塞：只有接收到队头数据时才会滑动，如果传输的是无序的数据则无法滑动

- 解决方法：一条QUIC连接上可以并发发送多个HTTP请求，并为他们都独立分配了一个滑动窗口，这样多个stream之间没有依赖关系

（4）流量控制

- TCP流量控制：让接收方告诉发送方它的接收窗口有多大从而让发送方根据接收方的实际接收能力控制发送的数据量
- 两种级别的流量控制
  - Stream级别：每个stream都有独立的滑动窗口所以每个stream都可以做流量控制防止单个stream消耗连接的全部接收缓冲
  - Connection流量控制：限制连接中所有Stream相加起来的总字节数防止发送方超过接收缓冲容量















