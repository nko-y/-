分层

（1）TCP/IP模型：应用层、传输层(TCP, UDP)、网络层(IP协议数据包转发路由)、链路层(数据传输与封装)

（2）OSI模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层



TCP和UDP

（1）区别：

- TCP面向连接，UDP面向无连接：TCP三次握手四次挥手，UDP支持一对一、一对多、多对一数据收发
- TCP可靠，UDP不可靠：无差别、不丢失、按序到达
- TCP基于字节流(拆分)，UDP基于报文(发送什么接收什么)

（2）收发数据：

- tcp：send, recv
  - IP层也会分片为什么还要TCP层的分段？因为想要小部分数据丢失的时候能够快速重传，而不需要进行整体重传
- udp：sendto, recvfrom
  - UDP不会进行分段，在IP层会根据MTU的限制进行分片
  - UDP一个要么没有到达，要么就全部收到进行重组

用户态数据系统调用到内核态变成socket，根据TCP(超过MSS就进行分段)还是UDP，加上报文头(IP分片)，经过网卡发送到互联网

MTU = IP头部 + TCP头部 + 数据块

MSS = 数据块

问题？客户端通过TCP和UDP分别发送了三个包，服务端会收到几个包？

- TCP可能受到一个(包很小)，两个，三个，... n个（会分段）
- 极限情况0个，一个，两个，三个(都没有丢失)



TCP如何实现可靠性传输

（1）重传机制：在一定时间没有收到接收端应答时会重传数据

- 停等协议
- 回退重传
- 选择性重传

（2）数据包检验机制：发送数据包时同时需要发送一个校验和，接收端收到数据包校验校验和，如果校验失败会要求发送端重传

（3）控制流机制：通过限制发送速率来确保数据包的可靠传输



UDP可靠性传输

借鉴TCP上述有点，模拟TCP可靠性传输方式比如确认机制、重传机制、校验机制等



水平触发和边缘触发

（1）对象是IO多路复用

- select poll只有水平触发
- epoll默认水平触发也可以设置边缘触发

（2）目的：检测IO是否就绪，数据是否准备好？不知道客户端是否发送数据、建立数据【只是是否的关系，具体还是得IO函数来完成的】

（3）就绪通过什么形式告知：

- 可读事件：读缓冲区中有数据就会触发读事件(也可以设置一个水位，默认是1，只有大于水位才触发)。或者是全连接队列中有数据(有连接没有处理)。对端写端关闭，会触发当前端的读事件
- 可写事件：内核网络写缓冲区只要有可写空间就会触发写事件。连接建立成功

（4）怎么获取就绪数据：epoll_wait使得用户可以获得就绪事件

（5）区别

- 水平触发：只要满足IO就绪条件就会触发
  - epoll_wait没有处理下一次epoll_wait依旧可以获得就绪事件
  - epoll_wait没有完全处理全部数据
- 边缘触发：新的IO就绪事件到达就会触发一次【效率高些，因为少一些epoll_wait就少些用户内核态切换】
  - 上述水平触发两种情况拿不到通知

（6）总结：

- 可读事件采用水平触发，可写事件采取边缘触发(但linux并不支持)否则还得注销可写事件